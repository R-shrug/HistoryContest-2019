{"ast":null,"code":"\"use strict\";\n\nvar WeakMap = require(\"weak-map\");\n\nvar Dict = require(\"../dict\");\n\nvar rangeChangeDescriptors = new WeakMap(); // {isActive, willChangeListeners, changeListeners}\n\nmodule.exports = RangeChanges;\n\nfunction RangeChanges() {\n  throw new Error(\"Can't construct. RangeChanges is a mixin.\");\n}\n\nRangeChanges.prototype.getAllRangeChangeDescriptors = function () {\n  if (!rangeChangeDescriptors.has(this)) {\n    rangeChangeDescriptors.set(this, Dict());\n  }\n\n  return rangeChangeDescriptors.get(this);\n};\n\nRangeChanges.prototype.getRangeChangeDescriptor = function (token) {\n  var tokenChangeDescriptors = this.getAllRangeChangeDescriptors();\n  token = token || \"\";\n\n  if (!tokenChangeDescriptors.has(token)) {\n    tokenChangeDescriptors.set(token, {\n      isActive: false,\n      changeListeners: [],\n      willChangeListeners: []\n    });\n  }\n\n  return tokenChangeDescriptors.get(token);\n};\n\nRangeChanges.prototype.addRangeChangeListener = function (listener, token, beforeChange) {\n  // a concession for objects like Array that are not inherently observable\n  if (!this.isObservable && this.makeObservable) {\n    this.makeObservable();\n  }\n\n  var descriptor = this.getRangeChangeDescriptor(token);\n  var listeners;\n\n  if (beforeChange) {\n    listeners = descriptor.willChangeListeners;\n  } else {\n    listeners = descriptor.changeListeners;\n  } // even if already registered\n\n\n  listeners.push(listener);\n  Object.defineProperty(this, \"dispatchesRangeChanges\", {\n    value: true,\n    writable: true,\n    configurable: true,\n    enumerable: false\n  });\n  var self = this;\n  return function cancelRangeChangeListener() {\n    if (!self) {\n      // TODO throw new Error(\"Range change listener \" + JSON.stringify(token) + \" has already been canceled\");\n      return;\n    }\n\n    self.removeRangeChangeListener(listener, token, beforeChange);\n    self = null;\n  };\n};\n\nRangeChanges.prototype.removeRangeChangeListener = function (listener, token, beforeChange) {\n  var descriptor = this.getRangeChangeDescriptor(token);\n  var listeners;\n\n  if (beforeChange) {\n    listeners = descriptor.willChangeListeners;\n  } else {\n    listeners = descriptor.changeListeners;\n  }\n\n  var index = listeners.lastIndexOf(listener);\n\n  if (index === -1) {\n    throw new Error(\"Can't remove range change listener: does not exist: token \" + JSON.stringify(token));\n  }\n\n  listeners.splice(index, 1);\n};\n\nRangeChanges.prototype.dispatchRangeChange = function (plus, minus, index, beforeChange) {\n  var descriptors = this.getAllRangeChangeDescriptors();\n  var changeName = \"Range\" + (beforeChange ? \"WillChange\" : \"Change\");\n  descriptors.forEach(function (descriptor, token) {\n    if (descriptor.isActive) {\n      return;\n    } else {\n      descriptor.isActive = true;\n    } // before or after\n\n\n    var listeners;\n\n    if (beforeChange) {\n      listeners = descriptor.willChangeListeners;\n    } else {\n      listeners = descriptor.changeListeners;\n    }\n\n    var tokenName = \"handle\" + (token.slice(0, 1).toUpperCase() + token.slice(1)) + changeName; // notably, defaults to \"handleRangeChange\" or \"handleRangeWillChange\"\n    // if token is \"\" (the default)\n    // dispatch each listener\n\n    try {\n      listeners.slice().forEach(function (listener) {\n        if (listeners.indexOf(listener) < 0) {\n          return;\n        }\n\n        if (listener[tokenName]) {\n          listener[tokenName](plus, minus, index, this, beforeChange);\n        } else if (listener.call) {\n          listener.call(this, plus, minus, index, this, beforeChange);\n        } else {\n          throw new Error(\"Handler \" + listener + \" has no method \" + tokenName + \" and is not callable\");\n        }\n      }, this);\n    } finally {\n      descriptor.isActive = false;\n    }\n  }, this);\n};\n\nRangeChanges.prototype.addBeforeRangeChangeListener = function (listener, token) {\n  return this.addRangeChangeListener(listener, token, true);\n};\n\nRangeChanges.prototype.removeBeforeRangeChangeListener = function (listener, token) {\n  return this.removeRangeChangeListener(listener, token, true);\n};\n\nRangeChanges.prototype.dispatchBeforeRangeChange = function (plus, minus, index) {\n  return this.dispatchRangeChange(plus, minus, index, true);\n};","map":null,"metadata":{},"sourceType":"script"}