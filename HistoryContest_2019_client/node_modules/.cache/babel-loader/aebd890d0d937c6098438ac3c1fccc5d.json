{"ast":null,"code":"\"use strict\";\n\nmodule.exports = SortedSet;\n\nvar Shim = require(\"./shim\");\n\nvar GenericCollection = require(\"./generic-collection\");\n\nvar GenericSet = require(\"./generic-set\");\n\nvar PropertyChanges = require(\"./listen/property-changes\");\n\nvar RangeChanges = require(\"./listen/range-changes\");\n\nvar TreeLog = require(\"./tree-log\");\n\nfunction SortedSet(values, equals, compare, getDefault) {\n  if (!(this instanceof SortedSet)) {\n    return new SortedSet(values, equals, compare, getDefault);\n  }\n\n  this.contentEquals = equals || Object.equals;\n  this.contentCompare = compare || Object.compare;\n  this.getDefault = getDefault || Function.noop;\n  this.root = null;\n  this.length = 0;\n  this.addEach(values);\n} // hack so require(\"sorted-set\").SortedSet will work in MontageJS\n\n\nSortedSet.SortedSet = SortedSet;\nObject.addEach(SortedSet.prototype, GenericCollection.prototype);\nObject.addEach(SortedSet.prototype, GenericSet.prototype);\nObject.addEach(SortedSet.prototype, PropertyChanges.prototype);\nObject.addEach(SortedSet.prototype, RangeChanges.prototype);\nSortedSet.prototype.isSorted = true;\n\nSortedSet.prototype.constructClone = function (values) {\n  return new this.constructor(values, this.contentEquals, this.contentCompare, this.getDefault);\n};\n\nSortedSet.prototype.has = function (value, equals) {\n  if (equals) {\n    throw new Error(\"SortedSet#has does not support second argument: equals\");\n  }\n\n  if (this.root) {\n    this.splay(value);\n    return this.contentEquals(value, this.root.value);\n  } else {\n    return false;\n  }\n};\n\nSortedSet.prototype.get = function (value, equals) {\n  if (equals) {\n    throw new Error(\"SortedSet#get does not support second argument: equals\");\n  }\n\n  if (this.root) {\n    this.splay(value);\n\n    if (this.contentEquals(value, this.root.value)) {\n      return this.root.value;\n    }\n  }\n\n  return this.getDefault(value);\n};\n\nSortedSet.prototype.add = function (value) {\n  var node = new this.Node(value);\n\n  if (this.root) {\n    this.splay(value);\n\n    if (!this.contentEquals(value, this.root.value)) {\n      var comparison = this.contentCompare(value, this.root.value);\n\n      if (comparison === 0) {\n        throw new Error(\"SortedSet cannot contain incomparable but inequal values: \" + value + \" and \" + this.root.value);\n      }\n\n      if (this.dispatchesRangeChanges) {\n        this.dispatchBeforeRangeChange([value], [], this.root.index);\n      }\n\n      if (comparison < 0) {\n        // rotate right\n        //   R        N\n        //  / \\  ->  / \\\n        // l   r    l   R\n        // :   :    :    \\\n        //                r\n        //                :\n        node.right = this.root;\n        node.left = this.root.left;\n        this.root.left = null;\n        this.root.touch();\n      } else {\n        // rotate left\n        //   R        N\n        //  / \\  ->  / \\\n        // l   r    R   r\n        // :   :   /    :\n        //        l\n        //        :\n        node.left = this.root;\n        node.right = this.root.right;\n        this.root.right = null;\n        this.root.touch();\n      }\n\n      node.touch();\n      this.root = node;\n      this.length++;\n\n      if (this.dispatchesRangeChanges) {\n        this.dispatchRangeChange([value], [], this.root.index);\n      }\n\n      return true;\n    }\n  } else {\n    if (this.dispatchesRangeChanges) {\n      this.dispatchBeforeRangeChange([value], [], 0);\n    }\n\n    this.root = node;\n    this.length++;\n\n    if (this.dispatchesRangeChanges) {\n      this.dispatchRangeChange([value], [], 0);\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nSortedSet.prototype['delete'] = function (value, equals) {\n  if (equals) {\n    throw new Error(\"SortedSet#delete does not support second argument: equals\");\n  }\n\n  if (this.root) {\n    this.splay(value);\n\n    if (this.contentEquals(value, this.root.value)) {\n      var index = this.root.index;\n\n      if (this.dispatchesRangeChanges) {\n        this.dispatchBeforeRangeChange([], [value], index);\n      }\n\n      if (!this.root.left) {\n        this.root = this.root.right;\n      } else {\n        // remove the right side of the tree,\n        var right = this.root.right;\n        this.root = this.root.left; // the tree now only contains the left side of the tree, so all\n        // values are less than the value deleted.\n        // splay so that the root has an empty right child\n\n        this.splay(value); // put the right side of the tree back\n\n        this.root.right = right;\n      }\n\n      this.length--;\n\n      if (this.root) {\n        this.root.touch();\n      }\n\n      if (this.dispatchesRangeChanges) {\n        this.dispatchRangeChange([], [value], index);\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n};\n\nSortedSet.prototype.indexOf = function (value, index) {\n  if (index) {\n    throw new Error(\"SortedSet#indexOf does not support second argument: startIndex\");\n  }\n\n  if (this.root) {\n    this.splay(value);\n\n    if (this.contentEquals(value, this.root.value)) {\n      return this.root.index;\n    }\n  }\n\n  return -1;\n};\n\nSortedSet.prototype.find = function (value, equals, index) {\n  if (equals) {\n    throw new Error(\"SortedSet#find does not support second argument: equals\");\n  }\n\n  if (index) {\n    // TODO contemplate using splayIndex to isolate a subtree in\n    // which to search.\n    throw new Error(\"SortedSet#find does not support third argument: index\");\n  }\n\n  if (this.root) {\n    this.splay(value);\n\n    if (this.contentEquals(value, this.root.value)) {\n      return this.root;\n    }\n  }\n};\n\nSortedSet.prototype.findGreatest = function (at) {\n  if (this.root) {\n    at = at || this.root;\n\n    while (at.right) {\n      at = at.right;\n    }\n\n    return at;\n  }\n};\n\nSortedSet.prototype.findLeast = function (at) {\n  if (this.root) {\n    at = at || this.root;\n\n    while (at.left) {\n      at = at.left;\n    }\n\n    return at;\n  }\n};\n\nSortedSet.prototype.findGreatestLessThanOrEqual = function (value) {\n  if (this.root) {\n    this.splay(value);\n\n    if (this.contentCompare(this.root.value, value) > 0) {\n      return this.root.getPrevious();\n    } else {\n      return this.root;\n    }\n  }\n};\n\nSortedSet.prototype.findGreatestLessThan = function (value) {\n  if (this.root) {\n    this.splay(value);\n\n    if (this.contentCompare(this.root.value, value) >= 0) {\n      return this.root.getPrevious();\n    } else {\n      return this.root;\n    }\n  }\n};\n\nSortedSet.prototype.findLeastGreaterThanOrEqual = function (value) {\n  if (this.root) {\n    this.splay(value);\n\n    if (this.contentCompare(this.root.value, value) >= 0) {\n      return this.root;\n    } else {\n      return this.root.getNext();\n    }\n  }\n};\n\nSortedSet.prototype.findLeastGreaterThan = function (value) {\n  if (this.root) {\n    this.splay(value);\n\n    if (this.contentCompare(this.root.value, value) <= 0) {\n      return this.root.getNext();\n    } else {\n      return this.root;\n    }\n  }\n};\n\nSortedSet.prototype.pop = function () {\n  if (this.root) {\n    var found = this.findGreatest();\n    this[\"delete\"](found.value);\n    return found.value;\n  }\n};\n\nSortedSet.prototype.shift = function () {\n  if (this.root) {\n    var found = this.findLeast();\n    this[\"delete\"](found.value);\n    return found.value;\n  }\n};\n\nSortedSet.prototype.push = function () {\n  this.addEach(arguments);\n};\n\nSortedSet.prototype.unshift = function () {\n  this.addEach(arguments);\n};\n\nSortedSet.prototype.slice = function (start, end) {\n  var temp;\n  start = start || 0;\n  end = end || this.length;\n\n  if (start < 0) {\n    start += this.length;\n  }\n\n  if (end < 0) {\n    end += this.length;\n  }\n\n  var sliced = [];\n\n  if (this.root) {\n    this.splayIndex(start);\n\n    while (this.root.index < end) {\n      sliced.push(this.root.value);\n\n      if (!this.root.right) {\n        break;\n      }\n\n      this.splay(this.root.getNext().value);\n    }\n  }\n\n  return sliced;\n};\n\nSortedSet.prototype.splice = function (at, length\n/*...plus*/\n) {\n  return this.swap(at, length, Array.prototype.slice.call(arguments, 2));\n};\n\nSortedSet.prototype.swap = function (start, length, plus) {\n  if (start === undefined && length === undefined) {\n    return [];\n  }\n\n  start = start || 0;\n\n  if (start < 0) {\n    start += this.length;\n  }\n\n  if (length === undefined) {\n    length = Infinity;\n  }\n\n  var swapped = [];\n\n  if (this.root) {\n    // start\n    this.splayIndex(start); // minus length\n\n    for (var i = 0; i < length; i++) {\n      swapped.push(this.root.value);\n      var next = this.root.getNext();\n      this[\"delete\"](this.root.value);\n\n      if (!next) {\n        break;\n      }\n\n      this.splay(next.value);\n    }\n  } // plus\n\n\n  this.addEach(plus);\n  return swapped;\n}; // This is the simplified top-down splaying algorithm from: \"Self-adjusting\n// Binary Search Trees\" by Sleator and Tarjan. Guarantees that root.value\n// equals value if value exists. If value does not exist, then root will be\n// the node whose value either immediately preceeds or immediately follows value.\n// - as described in https://github.com/hij1nx/forest\n\n\nSortedSet.prototype.splay = function (value) {\n  var stub, left, right, temp, root, history;\n\n  if (!this.root) {\n    return;\n  } // Create a stub node.  The use of the stub node is a bit\n  // counter-intuitive: The right child of the stub node will hold the L tree\n  // of the algorithm.  The left child of the stub node will hold the R tree\n  // of the algorithm.  Using a stub node, left and right will always be\n  // nodes and we avoid special cases.\n  // - http://code.google.com/p/v8/source/browse/branches/bleeding_edge/src/splay-tree-inl.h\n\n\n  stub = left = right = new this.Node(); // The history is an upside down tree used to propagate new tree sizes back\n  // up the left and right arms of a traversal.  The right children of the\n  // transitive left side of the tree will be former roots while linking\n  // left.  The left children of the transitive walk to the right side of the\n  // history tree will all be previous roots from linking right.  The last\n  // node of the left and right traversal will each become a child of the new\n  // root.\n\n  history = new this.Node();\n  root = this.root;\n\n  while (true) {\n    var comparison = this.contentCompare(value, root.value);\n\n    if (comparison < 0) {\n      if (root.left) {\n        if (this.contentCompare(value, root.left.value) < 0) {\n          // rotate right\n          //        Root         L(temp)\n          //      /     \\       / \\\n          //     L(temp) R    LL    Root\n          //    / \\                /    \\\n          //  LL   LR            LR      R\n          temp = root.left;\n          root.left = temp.right;\n          root.touch();\n          temp.right = root;\n          temp.touch();\n          root = temp;\n\n          if (!root.left) {\n            break;\n          }\n        } // remember former root for repropagating length\n\n\n        temp = new Node();\n        temp.right = root;\n        temp.left = history.left;\n        history.left = temp; // link left\n\n        right.left = root;\n        right.touch();\n        right = root;\n        root = root.left;\n      } else {\n        break;\n      }\n    } else if (comparison > 0) {\n      if (root.right) {\n        if (this.contentCompare(value, root.right.value) > 0) {\n          // rotate left\n          //        Root         L(temp)\n          //      /     \\       / \\\n          //     L(temp) R    LL    Root\n          //    / \\                /    \\\n          //  LL   LR            LR      R\n          temp = root.right;\n          root.right = temp.left;\n          root.touch();\n          temp.left = root;\n          temp.touch();\n          root = temp;\n\n          if (!root.right) {\n            break;\n          }\n        } // remember former root for repropagating length\n\n\n        temp = new Node();\n        temp.left = root;\n        temp.right = history.right;\n        history.right = temp; // link right\n\n        left.right = root;\n        left.touch();\n        left = root;\n        root = root.right;\n      } else {\n        break;\n      }\n    } else {\n      // equal or incomparable\n      break;\n    }\n  } // reassemble\n\n\n  left.right = root.left;\n  left.touch();\n  right.left = root.right;\n  right.touch();\n  root.left = stub.right;\n  root.right = stub.left; // propagate new lengths\n\n  while (history.left) {\n    history.left.right.touch();\n    history.left = history.left.left;\n  }\n\n  while (history.right) {\n    history.right.left.touch();\n    history.right = history.right.right;\n  }\n\n  root.touch();\n  this.root = root;\n}; // an internal utility for splaying a node based on its index\n\n\nSortedSet.prototype.splayIndex = function (index) {\n  if (this.root) {\n    var at = this.root;\n    var atIndex = this.root.index;\n\n    while (atIndex !== index) {\n      if (atIndex > index && at.left) {\n        at = at.left;\n        atIndex -= 1 + (at.right ? at.right.length : 0);\n      } else if (atIndex < index && at.right) {\n        at = at.right;\n        atIndex += 1 + (at.left ? at.left.length : 0);\n      } else {\n        break;\n      }\n    }\n\n    this.splay(at.value);\n    return this.root.index === index;\n  }\n\n  return false;\n};\n\nSortedSet.prototype.reduce = function (callback, basis, thisp) {\n  if (this.root) {\n    basis = this.root.reduce(callback, basis, 0, thisp, this);\n  }\n\n  return basis;\n};\n\nSortedSet.prototype.reduceRight = function (callback, basis, thisp) {\n  if (this.root) {\n    basis = this.root.reduceRight(callback, basis, this.length - 1, thisp, this);\n  }\n\n  return basis;\n};\n\nSortedSet.prototype.min = function (at) {\n  var least = this.findLeast(at);\n\n  if (least) {\n    return least.value;\n  }\n};\n\nSortedSet.prototype.max = function (at) {\n  var greatest = this.findGreatest(at);\n\n  if (greatest) {\n    return greatest.value;\n  }\n};\n\nSortedSet.prototype.one = function () {\n  return this.min();\n};\n\nSortedSet.prototype.clear = function () {\n  var minus;\n\n  if (this.dispatchesRangeChanges) {\n    minus = this.toArray();\n    this.dispatchBeforeRangeChange([], minus, 0);\n  }\n\n  this.root = null;\n  this.length = 0;\n\n  if (this.dispatchesRangeChanges) {\n    this.dispatchRangeChange([], minus, 0);\n  }\n};\n\nSortedSet.prototype.iterate = function (start, end) {\n  return new this.Iterator(this, start, end);\n};\n\nSortedSet.prototype.Iterator = Iterator;\n\nSortedSet.prototype.summary = function () {\n  if (this.root) {\n    return this.root.summary();\n  } else {\n    return \"()\";\n  }\n};\n\nSortedSet.prototype.log = function (charmap, logNode, callback, thisp) {\n  charmap = charmap || TreeLog.unicodeRound;\n  logNode = logNode || this.logNode;\n\n  if (!callback) {\n    callback = console.log;\n    thisp = console;\n  }\n\n  callback = callback.bind(thisp);\n\n  if (this.root) {\n    this.root.log(charmap, logNode, callback, callback);\n  }\n};\n\nSortedSet.prototype.logNode = function (node, log, logBefore) {\n  log(\" \" + node.value);\n};\n\nSortedSet.logCharsets = TreeLog;\nSortedSet.prototype.Node = Node;\n\nfunction Node(value) {\n  this.value = value;\n  this.left = null;\n  this.right = null;\n  this.length = 1;\n} // TODO case where no basis is provided for reduction\n\n\nNode.prototype.reduce = function (callback, basis, index, thisp, tree, depth) {\n  depth = depth || 0;\n\n  if (this.left) {\n    // prerecord length to be resistant to mutation\n    var length = this.left.length;\n    basis = this.left.reduce(callback, basis, index, thisp, tree, depth + 1);\n    index += length;\n  }\n\n  basis = callback.call(thisp, basis, this.value, index, tree, this, depth);\n  index += 1;\n\n  if (this.right) {\n    basis = this.right.reduce(callback, basis, index, thisp, tree, depth + 1);\n  }\n\n  return basis;\n};\n\nNode.prototype.reduceRight = function (callback, basis, index, thisp, tree, depth) {\n  depth = depth || 0;\n\n  if (this.right) {\n    basis = this.right.reduce(callback, basis, index, thisp, tree, depth + 1);\n    index -= this.right.length;\n  }\n\n  basis = callback.call(thisp, basis, this.value, this.value, tree, this, depth);\n  index -= 1;\n\n  if (this.left) {\n    basis = this.left.reduce(callback, basis, index, thisp, tree, depth + 1);\n  }\n\n  return basis;\n};\n\nNode.prototype.touch = function () {\n  this.length = 1 + (this.left ? this.left.length : 0) + (this.right ? this.right.length : 0);\n  this.index = this.left ? this.left.length : 0;\n};\n\nNode.prototype.checkIntegrity = function () {\n  var length = 1;\n  length += this.left ? this.left.checkIntegrity() : 0;\n  length += this.right ? this.right.checkIntegrity() : 0;\n  if (this.length !== length) throw new Error(\"Integrity check failed: \" + this.summary());\n  return length;\n}; // get the next node in this subtree\n\n\nNode.prototype.getNext = function () {\n  var node = this;\n\n  if (node.right) {\n    node = node.right;\n\n    while (node.left) {\n      node = node.left;\n    }\n\n    return node;\n  }\n}; // get the previous node in this subtree\n\n\nNode.prototype.getPrevious = function () {\n  var node = this;\n\n  if (node.left) {\n    node = node.left;\n\n    while (node.right) {\n      node = node.right;\n    }\n\n    return node;\n  }\n};\n\nNode.prototype.summary = function () {\n  var value = this.value || \"-\";\n  value += \" <\" + this.length;\n\n  if (!this.left && !this.right) {\n    return \"(\" + value + \")\";\n  }\n\n  return \"(\" + value + \" \" + (this.left ? this.left.summary() : \"()\") + \", \" + (this.right ? this.right.summary() : \"()\") + \")\";\n};\n\nNode.prototype.log = function (charmap, logNode, log, logAbove) {\n  var self = this;\n  var branch;\n\n  if (this.left && this.right) {\n    branch = charmap.intersection;\n  } else if (this.left) {\n    branch = charmap.branchUp;\n  } else if (this.right) {\n    branch = charmap.branchDown;\n  } else {\n    branch = charmap.through;\n  }\n\n  var loggedAbove;\n  this.left && this.left.log(charmap, logNode, function innerWrite(line) {\n    if (!loggedAbove) {\n      loggedAbove = true; // leader\n\n      logAbove(charmap.fromBelow + charmap.through + line);\n    } else {\n      // below\n      logAbove(charmap.strafe + \" \" + line);\n    }\n  }, function innerWriteAbove(line) {\n    // above\n    logAbove(\"  \" + line);\n  });\n  var loggedOn;\n  logNode(this, function innerWrite(line) {\n    if (!loggedOn) {\n      loggedOn = true;\n      log(branch + line);\n    } else {\n      log((self.right ? charmap.strafe : \" \") + line);\n    }\n  }, function innerWriteAbove(line) {\n    logAbove((self.left ? charmap.strafe : \" \") + line);\n  });\n  var loggedBelow;\n  this.right && this.right.log(charmap, logNode, function innerWrite(line) {\n    if (!loggedBelow) {\n      loggedBelow = true;\n      log(charmap.fromAbove + charmap.through + line);\n    } else {\n      log(\"  \" + line);\n    }\n  }, function innerWriteAbove(line) {\n    log(charmap.strafe + \" \" + line);\n  });\n};\n\nfunction Iterator(set, start, end) {\n  this.set = set;\n  this.prev = null;\n  this.end = end;\n\n  if (start) {\n    var next = this.set.findLeastGreaterThanOrEqual(start);\n\n    if (next) {\n      this.set.splay(next.value);\n      this.prev = next.getPrevious();\n    }\n  }\n}\n\nIterator.prototype.__iterationObject = null;\nObject.defineProperty(Iterator.prototype, \"_iterationObject\", {\n  get: function () {\n    return this.__iterationObject || (this.__iterationObject = {\n      done: false,\n      value: null\n    });\n  }\n});\n\nIterator.prototype.next = function () {\n  var next;\n\n  if (this.prev) {\n    next = this.set.findLeastGreaterThan(this.prev.value);\n  } else {\n    next = this.set.findLeast();\n  }\n\n  if (!next) {\n    this._iterationObject.done = true;\n    this._iterationObject.value = void 0;\n  } else {\n    if (this.end !== undefined && this.set.contentCompare(next.value, this.end) >= 0) {\n      this._iterationObject.done = true;\n      this._iterationObject.value = void 0;\n    } else {\n      this.prev = next;\n      this._iterationObject.value = next.value;\n    }\n  }\n\n  return this._iterationObject;\n};","map":null,"metadata":{},"sourceType":"script"}